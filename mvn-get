#!/bin/bash
SCRIPT="$(/usr/bin/readlink -f "${0}")"
BASEDIR="$(/usr/bin/dirname "${SCRIPT}")"
SCRIPT="$(/usr/bin/basename "${SCRIPT}")"

set -euo pipefail

timestamp()
{
	/usr/bin/date -Ins -u
}

say()
{
	echo -e "$(timestamp): ${@}"
}

fail()
{
	say "❌ ${@}" 1>&2
	exit ${EXIT_CODE:-1}
}

download()
{
	local URL="${1}"
	local AUTH="${2:-""}"
	local DEST="${3:-""}"
	[ -n "${AUTH}" ] && AUTH="--user ${AUTH}"
	[ -n "${DEST}" ] && DEST=(--output "${DEST}")
	"${CURL}" --location --fail --disallow-username-in-url --config <(echo -n "${AUTH}") "${DEST[@]}" "${URL}"
}

usage()
{
	{
		echo -e "usage: ${BASH_ARGV0:-${BASH_SOURCE:-${0}}} artifactSpec repoUrl target"
		echo -e ""
		echo -e "\tArtifact specs are of the form artifact[@repo]=target"
		echo -e ""
		echo -e "\t\tartifactSpec: groupId:artifactId[:version[:packaging[:classifier]]]"
		echo -e "\t\trepoUrl:      URL to the Maven repository housing the artifact"
		echo -e "\t\ttarget:       The final path where the file will be copied into. If it's"
		echo -e "\t\t              a directory, the downloaded filename will be preserved."
		echo -e ""
	} 1>&2
	exit 1
}

[ ${#} -eq 3 ] || usage

ARTIFACT="${1}"
REPO_URL="${2}"
DEST="${3}"

[[ "${ARTIFACT}" =~ ^([^:[:space:]]+):([^:[:space:]]+)(:([^:[:space:]]+)?(:([^:[:space:]]+)?(:([^:[:space:]]+)?)?)?)?$ ]] || fail "The artifact string [${ARTIFACT}] is not valid"
GROUP_ID="${BASH_REMATCH[1]}"
ARTIFACT_ID="${BASH_REMATCH[2]}"
VERSION="${BASH_REMATCH[4]}"
EXTENSION="${BASH_REMATCH[6]}"
CLASSIFIER="${BASH_REMATCH[8]}"

[ -n "${VERSION}" ] || VERSION="RELEASE"

XMLSTARLET="$(type -P xmlstarlet)" || fail "xmlstarlet is not installed - cannot proceed"
CURL="$(type -P curl)" || fail "curl is not installed - cannot proceed"

if [ -v MVN_GET_SERVER_ID ] ; then
	# We have a server ID whose username/password combo we wish to consume
	[ -n "${MVN_GET_SERVER_ID}" ] || fail "The value in MVN_GET_SERVER_ID may not be the empty string"
	MVN_CRYPT="$(type -P "${BASEDIR}/mvn-crypt")" || MVN_CRYPT="$(type -P mvn-crypt)" || fail "mvn-crypt is not installed - cannot proceed"
	MVN_GET_USERNAME="$("${MVN_CRYPT}" --quiet server decrypt "${MVN_GET_SERVER_ID}" username)"
	[ -n "${MVN_GET_USERNAME}" ] || fail "The username for server [${MVN_GET_SERVER_ID}] is empty or nonexistent"
	MVN_GET_PASSWORD="$("${MVN_CRYPT}" --quiet server decrypt "${MVN_GET_SERVER_ID}" password)"
	[ -n "${MVN_GET_PASSWORD}" ] || fail "The password for server [${MVN_GET_SERVER_ID}] is empty or nonexistent"
fi

AUTH=""
if [ -v MVN_GET_USERNAME ] && [ -v MVN_GET_PASSWORD ] ; then
	[ -n "${MVN_GET_USERNAME}" ] || fail "The value in MVN_GET_USERNAME may not be the empty string"
	[ -n "${MVN_GET_PASSWORD}" ] || fail "The value in MVN_GET_PASSWORD may not be the empty string"
	AUTH="${MVN_GET_USERNAME}:${MVN_GET_PASSWORD}"
fi

[[ "${REPO_URL,,}" =~ ^https?:// ]] || fail "Repository [${REPO_URL}] from artifact parameter [${n}] is not valid"

GROUP_PATH="${GROUP_ID//./\/}"
BASE="${REPO_URL}/${GROUP_PATH}/${ARTIFACT_ID}"

say "👉 Downloading:"
say "\tArtifact:    [${ARTIFACT}]"
say "\tRepository:  [${REPO_URL}]"
say "\tDestination: [${DEST}]"

FINAL_VERSION="${VERSION}"
SUPPORT_SNAPSHOT="true"
if [ "${VERSION}" == "LATEST" ] || [ "${VERSION}" == "RELEASE" ] ; then
	# This shouldn't be necessary, as the metadata should never reference SNAPSHOTS
	# in the <release> element, but we take precautions nonetheless
	[ "${VERSION}" == "RELEASE" ] && SUPPORT_SNAPSHOT="false"
	say "⚠️ Identifying the ${VERSION} artifact version to download..."
	XML="$(download "${BASE}/maven-metadata.xml" "${AUTH}" 2>/dev/null)" || fail "Failed to download the artifact metadata for ${GROUP_ID}:${ARTIFACT_ID} from [${BASE}/maven-metadata.xml]"
	FINAL_VERSION="$("${XMLSTARLET}" sel -t -v "/metadata/versioning/${VERSION,,}" <<< "${XML}")"
	say "\t✅ The ${VERSION} version is ${FINAL_VERSION}"
	VERSION="${FINAL_VERSION}"
fi

# If the final version is a snapshot, then we must resolve that
BASE+="/${VERSION}"
if "${SUPPORT_SNAPSHOT}" && [[ "${VERSION}" =~ -SNAPSHOT$ ]] ; then
	say "⚠️ This version is a SNAPSHOT - identifying the final artifact to download"
	XML="$(download "${BASE}/maven-metadata.xml" "${AUTH}" 2>/dev/null)" || fail "Failed to download the artifact metadata for ${GROUP_ID}:${ARTIFACT_ID}:${VERSION} from [${BASE}/maven-metadata.xml]"
	TIMESTAMP="$("${XMLSTARLET}" sel -t -v '/metadata/versioning/snapshot/timestamp' <<< "${XML}")"
	BUILD_NUMBER="$("${XMLSTARLET}" sel -t -v '/metadata/versioning/snapshot/buildNumber' <<< "${XML}")"
	FINAL_VERSION="$(echo -n "${VERSION}" | sed -e "s/-SNAPSHOT$/-${TIMESTAMP}-${BUILD_NUMBER}/g")"
	say "\t✅ The latest SNAPSHOT version is ${FINAL_VERSION}"
fi

BASE="${BASE}/${ARTIFACT_ID}-${FINAL_VERSION}"
TAB=""
if [ -z "${EXTENSION}" ] ; then
	say "⚠️ Packaging (type) not provided, must identify it from the POM"
	POM="$(download "${BASE}.pom" "${AUTH}" 2>/dev/null)" || fail "Failed to download the artifact POM for ${GROUP_ID}:${ARTIFACT_ID}:${VERSION} from [${BASE}.pom]"
	EXTENSION="$("${XMLSTARLET}" sel -N "p=http://maven.apache.org/POM/4.0.0" -t -v '/p:project/p:packaging' <<< "${POM}")"
	[ -z "${EXTENSION}" ] && EXTENSION="jar"
	TAB="\t"
fi
say "${TAB}✅ Will download the ${EXTENSION} artifact"

# Must be given explicitly ...
if [ -n "${CLASSIFIER}" ] ; then
	CLASSIFIER="-${CLASSIFIER}"
	say "✅ The classifier is ${CLASSIFIER}"
fi

URL="${BASE}${CLASSIFIER}.${EXTENSION}"
FILENAME="${URL##*/}"

# Check to see if the destination is 
if [ -e "${DEST}" ] ; then
	if [ -d "${DEST}" ] ; then
		# It's a directory, so preserve the artifact's filename
		DEST="$(readlink -f "${DEST}")/${FILENAME}"
	elif [ -f "${DEST}" ] ; then
		# It's a file, so clobber it
		DEST="$(readlink -f "${DEST}")"
	else
		fail "The target path at [${DEST}] is neither a directory nor a regular file, cannot continue"
	fi
else
	# It doesn't exist ... check to see if the parent exists ... if it
	# does, and is a directory, then we use DEST as the full filename.
	PARENT="$(dirname "${DEST}")"
	[ -e "${PARENT}" ] || mkdir -p "${PARENT}" || fail "Failed to create the parent directory [${PARENT}] ... can't save the download into [${DEST}]"
	[ -d "${PARENT}" ] || fail "The path [${PARENT}] is not a directory ... can't save the download into [${DEST}]"
	PARENT="$(readlink -f "${PARENT}")"
	DEST="${PARENT}/$(basename "${DEST}")"
fi

say "👉 Final File: [${DEST}]"
say "👉 Final URL:  [${URL}]"
download "${URL}" "${AUTH}" "${DEST}" || fail "Failed to complete the download"
say "\t✅ Download successful!"
